<!DOCTYPE html>
<html>

<head>
    <title></title>
    <style type="text/css">
        #main-canvas {
            display: block;
            margin: auto;
        }
        .popup {
            position: fixed;
            top: 100px;
            left: 50%;
            width: 380px;
            margin-left: -190px;
            padding: 20px;
            background: white;
            border: 1px solid gray;
        }
        .popup h2 {
            margin-top: 0;
        }
        #settings-popup {
            display: none;
        }
        #settings-popup textarea {
            width: 100%;
            height: 20em;
        }
        .error {
            border: 1px solid red;
        }
    </style>
</head>

<body>
    <div class="popup" id="settings-popup">
        <h2>Settings</h2>
        <textarea></textarea>
        <button onclick="saveSettings()">Save</button>
    </div>
    <canvas id="main-canvas"></canvas>
    <script type="text/javascript">

    /** FROM: https://gist.github.com/eyecatchup/9536706
    * HSV to RGB color conversion
    *
    * H runs from 0 to 360 degrees
    * S and V run from 0 to 100
    *
    * Ported from the excellent java algorithm by Eugene Vishnevsky at:
    * http://www.cs.rit.edu/~ncs/color/t_convert.html
    */
    function hsvToRgb(h, s, v) {
        var r, g, b;
        var i;
        var f, p, q, t;

        // Make sure our arguments stay in-range
        h = Math.max(0, Math.min(360, h));
        s = Math.max(0, Math.min(100, s));
        v = Math.max(0, Math.min(100, v));

        // We accept saturation and value arguments from 0 to 100 because that's
        // how Photoshop represents those values. Internally, however, the
        // saturation and value are calculated from a range of 0 to 1. We make
        // That conversion here.
        s /= 100;
        v /= 100;

        if(s == 0) {
            // Achromatic (grey)
            r = g = b = v;
            return [
                Math.round(r * 255),
                Math.round(g * 255),
                Math.round(b * 255)
            ];
        }

        h /= 60; // sector 0 to 5
        i = Math.floor(h);
        f = h - i; // factorial part of h
        p = v * (1 - s);
        q = v * (1 - s * f);
        t = v * (1 - s * (1 - f));

        switch(i) {
            case 0:
                r = v;
                g = t;
                b = p;
                break;

            case 1:
                r = q;
                g = v;
                b = p;
                break;

            case 2:
                r = p;
                g = v;
                b = t;
                break;

            case 3:
                r = p;
                g = q;
                b = v;
                break;

            case 4:
                r = t;
                g = p;
                b = v;
                break;

            default: // case 5:
                r = v;
                g = p;
                b = q;
        }

        return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
        ];
    }

    /**
     * An object to represent an LFO
     *
     * minValue - The minimum value to set
     * maxValue - The maximum value to set
     * speed - The amount to increase the value by in 1 second
     * callback - A function that takes a Blob object and the value to be set
               as parameters
     * loopRound (optional) - If this is true then jump from maxValue to
                              minValue instead of going back down (defaults to
                              false)
     */
    function LFO(minValue, maxValue, speed, callback, loopRound) {
        loopRound = loopRound || false

        var value = (minValue + maxValue) / 2;

        // The 'direction' to modulate the value. +1 for up (i.e. value
        // increases) and -1 for down
        var direction = 1;

        this.update = function(dt) {
            var change = speed * dt;
            value += change * direction;

            // Make sure the value has not gone out of range
            if (value > maxValue) {
                // Work out how far past the max value we have gone, and set
                // the value to the proper value
                var extra = value - maxValue;

                if (loopRound) {
                    value = minValue + extra;
                }
                else {
                    // Change direction
                    direction *= -1;
                    value = maxValue - extra;
                }
            }
            // (Same as above but for min value)
            if (value < minValue) {
                // We do not need to consider loopRound here because direction
                // will always be 1 if loopRound is true

                direction *= -1;
                var extra = minValue - value;
                value = minValue + extra;
            }

            callback(value);
        }
    }

    /**
     * An object representing a colour as HSV
     */
    function Colour(h, s, v) {

        /**
         * Update this colour's HSV value and convert it to RGB
         */
        this.update = function(h, s, v) {
            this.hue = h % 360;
            this.sat = s;
            this.val = v;

            var rgb = hsvToRgb(this.hue, this.sat, this.val);
            // Store the RGB string on the object so we don't have to convert
            // every frame
            this.rbgString = "rgb(" + rgb.join(",") + ")";
        }

        this.update(h, s, v);
    }

    /**
     * A blob object
     *
     * x - x-coordinate
     * y - y-coordinate
     * bearing - Bearing from north in radians
     * color - A Colour object representing the colour of this blob
     */
    function Blob(x, y, bearing, colour) {
        this.x = x;
        this.y = y;
        this.bearing = bearing;
        this.colour = colour;

        // This angle is added to the bearing each frame (e.g. to be modulated
        // by an LFO)
        this.bearingShift = 0;

        /**
         * Update this blob's position
         */
        this.update = function(dt) {
            // Move this blob if the pause key is not down
            if (!(KEY_NAMES.pause in pressedKeys)) {
                var speed = KEY_NAMES.slow in pressedKeys ?
                            settings.blob.slowSpeed : settings.blob.speed;

                var bearing = this.bearing + this.bearingShift;

                this.x += Math.sin(bearing) * speed * dt;
                this.y -= Math.cos(bearing) * speed * dt;
            }
        }

        /**
         * Draw this blob as a circle on the canvas
         */
        this.draw = function() {
            ctx.fillStyle = this.colour.rbgString;
            ctx.beginPath();
            ctx.arc(
                this.x, this.y, settings.blob.radius, 0, 2 * Math.PI
            );
            ctx.fill();
        }
    }

    /**
      * Adjust the bearing of each blob in the array to head towards the point
      * (x, y)
      */
    function attractBlobs(blobs, x, y) {
        for (var i in blobs) {
            var dx = x - blobs[i].x;
            var dy = -(y - blobs[i].y);
            blobs[i].bearing = Math.atan2(dx, dy);
        }
    }

    /**
     * Move every blob in the array to the point (x, y)
     */
    function moveBlobs(blobs, x, y) {
        for (var i in blobs) {
            blobs[i].x = x;
            blobs[i].y = y;
        }
    }

    /**
     * Move all blobs to the point if paused, otherwise make them head towards
     * the point
     */
    function handleClick(x, y) {
        if (KEY_NAMES.pause in pressedKeys) {
            moveBlobs(blobs, x, y);
        }
        else {
            attractBlobs(blobs, x, y);
        }
    }

    /**
     * Return an array of blobs, optionally at a specified co-ordinate
     *
     * count - The number of blobs to create
     * x (optional) - The x-coordinate to create the blobs at (defaults to using a
     *               random coordinate for each blob)
     * y (optional) - Same as x for y-coordinate
     */
    function createBlobs(count, x, y) {
        var blobs = [];
        for (var i=0; i<count; i++) {
            var bearing = Math.random() * 2 * Math.PI;

            var hue = 120;
            var sat = Math.random() * 100;
            var val = Math.random() * 100;
            var colour = new Colour(hue, sat, val);

            var tx = x || Math.random() * canvas.width;
            var ty = y || Math.random() * canvas.height;

            blobs.push(new Blob(tx, ty, bearing, colour));
        }
        return blobs;
    }

    /**
     * Set up the canvas, blobs and LFOs
     */
    function setup() {
        canvas.width = settings.canvas.width;
        canvas.height = settings.canvas.height;

        blobs = createBlobs(settings.blob.count);
        lfos = {};

        // Modulate blob bearing
        lfos.bearingShift = new LFO(-Math.PI/4, Math.PI/4, 1,
            function(value) {
                for (var i in blobs) {
                    blobs[i].bearingShift = value;
                }
            }
        );

        // Modulate blob hue
        lfos.hue = new LFO(0, 360, 30, function(value) {
            for (var i in blobs) {
                var colour = blobs[i].colour;
                blobs[i].colour.update(
                    value, colour.sat, colour.val
                );
            }
        }, true);

        // lfos.speed = new LFO(100, 300, 200, function(value) {
        //     settings.blob.speed = value;
        // });

        stopped = false;
    }

    /**
     * The main update loop that is called each frame
     * dt - Time in seconds since the last frame
     */
    function mainUpdate(dt) {
        for (var i in lfos) {
            // Skip updating this LFO if it's bearingShift and the key is not
            // pressed
            if (i === "bearingShift" && !(KEY_NAMES.wavy in pressedKeys)) {
                continue;
            }
            lfos[i].update(dt);
        }

        for (var i in blobs) {
            blobs[i].update(dt);
        }

        draw();
    }

    /**
     * Clear the screen and draw all objects
     */
    function draw() {
        if (settings.clearCanvas) {
            // Clear screen
            ctx.fillStyle = settings.canvas.backgroundColour;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        // Draw border
        ctx.strokeRect(0, 0, canvas.width, canvas.height);

        for (var i in blobs) {
            blobs[i].draw();
        }
    }

    /**
     * Show a popup containing a textarea to edit the settings object as JSON
     */
    function showSettings() {
        settingsDisplayed = true;
        var settingsPopup = document.getElementById("settings-popup");
        var textarea = settingsPopup.getElementsByTagName("textarea")[0];
        textarea.innerHTML = JSON.stringify(settings, null, 4);
        settingsPopup.style.display = "block";
    }

    /**
     * Close the settings popup and update the settings object
     */
    function saveSettings() {
        var settingsPopup = document.getElementById("settings-popup");
        var textarea = settingsPopup.getElementsByTagName("textarea")[0];

        try {
            settings = JSON.parse(textarea.value);
            setup();
            settingsPopup.style.display = "none";
            settingsDisplayed = false;
            // Remove error class in case there was an error before
            textarea.className = "";
        }
        catch (e) {
            // User did not enter valid JSON
            textarea.className = "error";
        }
    }

    // User customisable settings
    var settings = {
        "canvas": {
            "width": 930,
            "height": 600,
            "backgroundColour": "black"
        },
        "blob": {
            "radius": 3,
            "count": 2500,
            "speed": 100,
            "slowSpeed": 50
        },
        "clearCanvas": true
    };

    var canvas = document.getElementById("main-canvas");
    var ctx = canvas.getContext("2d");

    var blobs = [];
    var lfos = {};

    var stopped = true;

    // Start main loop
    var then = Date.now();
    setInterval(function() {
        if (!stopped) {
            var now = Date.now();
            var dt = (now - then) / 1000;
            then = now;
            mainUpdate(dt);
        }
    }, 1);

    canvas.addEventListener("click", function(event) {
        var x = event.offsetX;
        var y = event.offsetY;
        handleClick(x, y);
    });

    var KEY_NAMES = {
        "pause": 16, // shift
        "randomise": 82, // r
        "center": 67, // c
        "slow": 83, // s
        "wavy": 87, // w
        "settings": 79, // o
        "toggleClear": 75, // k
    }
    var pressedKeys = {};
    var settingsDisplayed = false;
    window.addEventListener("keydown", function(event) {
        console.log(event.keyCode);

        pressedKeys[event.keyCode] = true;

        switch (event.keyCode) {
            // Randomise the bearing of all blobs
            case KEY_NAMES.randomise:
                for (var i in blobs) {
                    blobs[i].bearing = Math.random() * 2 * Math.PI;
                }
                break;

            // Click at the center of the canvas
            case KEY_NAMES.center:
                handleClick(canvas.width / 2, canvas.height / 2);
                break;

            // Show settings
            case KEY_NAMES.settings:
                if (!settingsDisplayed) {
                    showSettings();
                }
                break;

            case KEY_NAMES.toggleClear:
                settings.clearCanvas = !settings.clearCanvas;
                break;
        }
    });
    window.addEventListener("keyup", function(event) {
        delete pressedKeys[event.keyCode];

        switch (event.keyCode) {
            // Reset the bearing shift on all blobs when stopping wavy mode
            case KEY_NAMES.wavy:
                for (var i in blobs) {
                    blobs[i].bearingShift = 0;
                }
                break;
        }
    });

    setup();

    </script>
</body>

</html>
